generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum MatterStatus {
  DRAFT
  INTAKE
  REVIEW
  PACK_READY
  MAILED
  DEFECT
  DONE
}

enum PackStatus {
  DRAFT
  READY
}

enum WillSearchStatus {
  READY
  GENERATED
  SENT
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  matters       Matter[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Matter {
  id         String          @id @default(cuid())
  userId     String?
  user       User?           @relation(fields: [userId], references: [id])
  clientKey  String          @unique
  status     MatterStatus    @default(DRAFT)
  draft      IntakeDraft?
  pack       GeneratedPack?
  files      File[]
  audits     AuditLog[]
  emails     EmailLog[]
  willSearch WillSearchRequest[]
  resumeLinks ResumeToken[]
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
}

model IntakeDraft {
  id                    String   @id @default(cuid())
  matterId              String   @unique
  matter                Matter   @relation(fields: [matterId], references: [id])
  email                 String
  consent               Boolean
  exFullName            String
  exPhone               String?
  exCity                String
  exRelation            String
  decFullName           String
  decDateOfDeath        DateTime
  decCityProv           String
  hadWill               Boolean
  willLocation          String
  estateValueRange      String
  anyRealProperty       Boolean
  multipleBeneficiaries Boolean
  specialCircumstances  String?
  payload               Json?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
}

model WillSearchRequest {
  id        String            @id @default(cuid())
  matterId  String
  matter    Matter            @relation(fields: [matterId], references: [id])
  status    WillSearchStatus  @default(READY)
  packetUrl String?
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
}

model GeneratedPack {
  id        String     @id @default(cuid())
  matterId  String     @unique
  matter    Matter     @relation(fields: [matterId], references: [id])
  status    PackStatus @default(DRAFT)
  zipUrl    String?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

model File {
  id        String   @id @default(cuid())
  matterId  String
  matter    Matter   @relation(fields: [matterId], references: [id])
  name      String
  mimeType  String
  size      Int
  url       String
  createdAt DateTime @default(now())
}

model EmailLog {
  id        String   @id @default(cuid())
  matterId  String?
  matter    Matter?  @relation(fields: [matterId], references: [id])
  to        String
  subject   String
  template  String
  meta      Json?
  createdAt DateTime @default(now())
}

model ResumeToken {
  token     String   @id
  matterId  String
  matter    Matter   @relation(fields: [matterId], references: [id])
  email     String
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model AuditLog {
  id        String   @id @default(cuid())
  matterId  String
  matter    Matter   @relation(fields: [matterId], references: [id])
  actorId   String?
  action    String
  meta      Json?
  createdAt DateTime @default(now())
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?  @db.Text
  access_token      String?  @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?  @db.Text
  session_state     String?

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expires      DateTime
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
